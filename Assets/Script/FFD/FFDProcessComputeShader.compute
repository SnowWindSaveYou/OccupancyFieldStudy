#pragma kernel CalcFFD
#pragma kernel Forward

struct FFDHandler{
	float3 initPos;
	float3 currPos;
};

RWTexture3D<float3> _FFDTex;
Texture3D<float> _DataTex;
RWTexture3D<float> _TargetTex;
StructuredBuffer<FFDHandler> _FFDHandlerBuffer;
uint _FFDHandlerBufferCount; 

float3 _gridSize;

SamplerState myLinearClampSampler;
float SampleLinear(float3 p)
{
	return _DataTex.SampleLevel(myLinearClampSampler, p, 0).x;
}

[numthreads(8,8,8)]
void CalcFFD (uint3 id : SV_DispatchThreadID)
{
	float3 idPos = (id+0.5)/_gridSize;
	if(_FFDHandlerBufferCount==0){
		_FFDTex[id] =0;
		return;
	}
	//todo

	float3 vecMove = 0;
	float sumW = 0;
	//for(int i = 0;i< _FFDHandlerBufferCount;++i){
	//	FFDHandler curr = _FFDHandlerBuffer[i];
	//	float dist = length(curr.initPos- idPos) ;
	//	float w =  exp(-(dist*dist)/(0.001));
	//	vecMove += -(curr.currPos- curr.initPos)*w;
	//	sumW+=w;
	//}
	//vecMove/=sumW;

	int nearIdx = -1;
	float minDist = 9999999;
	int nearIdx2 = -1;
	float minDist2 = 9999999;
	for(int i = 0;i< _FFDHandlerBufferCount;++i){
		FFDHandler curr = _FFDHandlerBuffer[i];
		float dist = length(curr.initPos- idPos) ;
		if(dist<minDist){
			minDist2 = minDist;
			nearIdx2 = nearIdx;
			minDist = dist;
			nearIdx = i;
		}else if(dist< minDist2){
			minDist2 = dist;
			nearIdx2 = i;
		}
	}

	FFDHandler h1 = _FFDHandlerBuffer[nearIdx];
	FFDHandler h2 = _FFDHandlerBuffer[nearIdx2];
	float3 vec1 = h1.currPos- h1.initPos;
	float3 vec2 = h2.currPos- h2.initPos;


	float wRange = minDist+minDist2;
	float w = minDist/wRange;
	 //w =  exp(-(w*w)/(0.001));

	vecMove = w* vec2 + saturate(1-w)* vec1; 

	float3 samplePos = saturate( idPos -vecMove);
	//_FFDTex[id] = vecMove;// todo

	float targetVal =SampleLinear(samplePos);
	_TargetTex[id] = targetVal;


}
[numthreads(8,8,8)]
void Forward (uint3 id : SV_DispatchThreadID)
{
	//float3 vecMove
}
